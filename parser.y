// Definitions:
%{
    #include <stdio.h>
    #include <stdlib.h>
    #include <math.h>
    int yylex(void);
    void yyerror(char *);
    extern FILE *yyin;
%}

// Data Types:
%union 
{
    int intData;
    float floatData;    
    char charData;
    char* stringData;
    int boolData;
    void* VOID_DATA;
}

// Tokens:
%token IF ELSE WHILE REPEAT UNTIL FOR SWITCH CASE CONST RETURN CONTINUE BREAK DEFAULT FUNCTION
%token OR AND NOT GT GE ST SE EQ NEQ
%token PLUS MINUS MULTIPLY DIVIDE MODULO POWER 
%token INCREREMENT DECREMENT
%token EQUAL SEMI_COLON COMMA COLON
%token LEFT_ROUND_BRACKET RIGHT_ROUND_BRACKET LEFT_CURLY_BRACKET RIGHT_CURLY_BRACKET 
%token <intData> INTVALUE BOOLVALUE 
%token <floatData> FLOATVALUE 
%token <charData> CHARVALUE 
%token <stringData> STRINGVALUE IDENTIFIER DATATYPE
%token UNKNOWN

//Datatypes For Grammar Rules:
%type <VOID_DATA>
%type <VOID_DATA>
%type <VOID_DATA>
%type <VOID_DATA>
%type <VOID_DATA>
%type <VOID_DATA>
%type <VOID_DATA>
%type <intData>
%type <intData>

// Operator Precedence:
%nonassoc LOWER_THAN_ELSE
%nonassoc ELSE
%left OR
%left AND
%left EQ NEQ
%left GT GE ST SE
%left PLUS MINUS
%left MULTIPLY DIVIDE MODULO
%right POWER
%right NOT
%right UMINUS

// Grammar Rules:
%%

PROGRAM: 
    STATEMENTS
    ;       

STATEMENTS: 
    /* empty */
    | STATEMENTS STATEMENT
    ;

STATEMENT: 
    DECLARATION SEMI_COLON
    | ASSIGNMENT SEMI_COLON
    | LOGICAL_EXPRESSION SEMI_COLON
    | RETURN_STATEMENT SEMI_COLON 
    | IF_STATEMENT
    | WHILE_STATEMENT
    | FOR_STATEMENT
    | REPEAT_STATEMENT
    | SWITCH_STATEMENT
    | FUNCTION_DEFINITION_IMPLEMENTATION
    | BREAK SEMI_COLON
    | CONTINUE SEMI_COLON
    | LEFT_CURLY_BRACKET STATEMENTS RIGHT_CURLY_BRACKET
    ;

DECLARATION: 
    DATATYPE IDENTIFIERS
    | DATATYPE DECLARATORS
    | CONST DATATYPE DECLARATORS
    ;

IDENTIFIERS: 
    IDENTIFIER
    | IDENTIFIERS COMMA IDENTIFIER
    ;

DECLARATORS: 
    DECLARATOR
    | DECLARATORS COMMA DECLARATOR
    ;

DECLARATOR: 
    IDENTIFIER
    | IDENTIFIER EQUAL LOGICAL_EXPRESSION
    ;

ASSIGNMENT: 
    IDENTIFIER EQUAL LOGICAL_EXPRESSION
    | IDENTIFIER INCREREMENT
    | IDENTIFIER DECREMENT
    | INCREREMENT IDENTIFIER
    | DECREMENT IDENTIFIER
    ;

IF_STATEMENT: 
    IF LEFT_ROUND_BRACKET LOGICAL_EXPRESSION RIGHT_ROUND_BRACKET LEFT_CURLY_BRACKET STATEMENTS RIGHT_CURLY_BRACKET %prec LOWER_THAN_ELSE
    | IF LEFT_ROUND_BRACKET LOGICAL_EXPRESSION RIGHT_ROUND_BRACKET LEFT_CURLY_BRACKET STATEMENTS RIGHT_CURLY_BRACKET ELSE LEFT_CURLY_BRACKET STATEMENTS RIGHT_CURLY_BRACKET
    ;

WHILE_STATEMENT: 
    WHILE LEFT_ROUND_BRACKET LOGICAL_EXPRESSION RIGHT_ROUND_BRACKET LEFT_CURLY_BRACKET STATEMENTS RIGHT_CURLY_BRACKET
    ;

REPEAT_STATEMENT: 
    REPEAT LEFT_CURLY_BRACKET STATEMENTS RIGHT_CURLY_BRACKET UNTIL LEFT_ROUND_BRACKET LOGICAL_EXPRESSION RIGHT_ROUND_BRACKET SEMI_COLON
    ;

FOR_STATEMENT: 
    FOR LEFT_ROUND_BRACKET ITERATOR SEMI_COLON LOGICAL_EXPRESSION SEMI_COLON ASSIGNMENT RIGHT_ROUND_BRACKET LEFT_CURLY_BRACKET STATEMENTS RIGHT_CURLY_BRACKET
    ;

ITERATOR: 
    IDENTIFIER EQUAL LOGICAL_EXPRESSION
    | DATATYPE IDENTIFIER EQUAL LOGICAL_EXPRESSION
    ;

SWITCH_STATEMENT: 
    SWITCH LEFT_ROUND_BRACKET LOGICAL_EXPRESSION RIGHT_ROUND_BRACKET LEFT_CURLY_BRACKET CASES DEFAULT_CASE RIGHT_CURLY_BRACKET
    ;

CASES: 
    /* empty */
    | CASES SINGLE_CASE
    ;

SINGLE_CASE: 
    CASE PRIMARY_CASE COLON STATEMENTS
    ;

DEFAULT_CASE: 
    /* empty */
    | DEFAULT COLON STATEMENTS
    ;

PRIMARY_CASE: 
    INTVALUE
    | CHARVALUE
    | BOOLVALUE
    | IDENTIFIER
    | FLOATVALUE
    | STRINGVALUE
    ;

RETURN_STATEMENT: 
    RETURN
    | RETURN LOGICAL_EXPRESSION
    ;

FUNCTION_DEFINITION_IMPLEMENTATION :
    FUNCTION DATATYPE IDENTIFIER LEFT_ROUND_BRACKET PARAMETER_LIST RIGHT_ROUND_BRACKET LEFT_CURLY_BRACKET STATEMENTS RIGHT_CURLY_BRACKET
    ;

PARAMETER_LIST:
    /* empty */                   
    | PARAM_LIST_NONEMPTY          
    ;

PARAM_LIST_NONEMPTY :
    DATATYPE IDENTIFIER                              
    | PARAM_LIST_NONEMPTY COMMA DATATYPE IDENTIFIER   
    ;

FUNCTION_CALL: 
    IDENTIFIER LEFT_ROUND_BRACKET ARGUMENT_LIST RIGHT_ROUND_BRACKET
    ;

ARGUMENT_LIST: 
    /* empty */
    | ARGUMENTS
    ;

ARGUMENTS: 
    LOGICAL_EXPRESSION
    | ARGUMENTS COMMA LOGICAL_EXPRESSION
    ;

LOGICAL_EXPRESSION: 
    LOGICAL_EXPRESSION OR LOGICAL_TERM
    | LOGICAL_TERM
    ;

LOGICAL_TERM: 
    LOGICAL_TERM AND EQUALITY_EXPRESSION
    | EQUALITY_EXPRESSION
    ;

EQUALITY_EXPRESSION: 
    EQUALITY_EXPRESSION EQ RELATIONAL_EXPRESSION
    | EQUALITY_EXPRESSION NEQ RELATIONAL_EXPRESSION
    | RELATIONAL_EXPRESSION
    ;

RELATIONAL_EXPRESSION: 
    RELATIONAL_EXPRESSION ST ADDITIVE_EXPRESSION
    | RELATIONAL_EXPRESSION GT ADDITIVE_EXPRESSION
    | RELATIONAL_EXPRESSION SE ADDITIVE_EXPRESSION
    | RELATIONAL_EXPRESSION GE ADDITIVE_EXPRESSION
    | ADDITIVE_EXPRESSION
    ;

ADDITIVE_EXPRESSION: 
    ADDITIVE_EXPRESSION PLUS MULTIPLICATIVE_EXPRESSION
    | ADDITIVE_EXPRESSION MINUS MULTIPLICATIVE_EXPRESSION
    | MULTIPLICATIVE_EXPRESSION
    ;

MULTIPLICATIVE_EXPRESSION: 
    MULTIPLICATIVE_EXPRESSION MULTIPLY EXPONENT_EXPRESSION
    | MULTIPLICATIVE_EXPRESSION DIVIDE EXPONENT_EXPRESSION
    | MULTIPLICATIVE_EXPRESSION MODULO EXPONENT_EXPRESSION
    | EXPONENT_EXPRESSION
    ;

EXPONENT_EXPRESSION: 
    EXPONENT_EXPRESSION POWER UNARY_EXPRESSION
    | UNARY_EXPRESSION
    ;

UNARY_EXPRESSION: 
    MINUS UNARY_EXPRESSION %prec UMINUS
    | NOT UNARY_EXPRESSION
    | PRIMARY_EXPRESSION
    ;

PRIMARY_EXPRESSION: 
    INTVALUE
    | FLOATVALUE
    | CHARVALUE
    | BOOLVALUE
    | STRINGVALUE
    | IDENTIFIER
    | FUNCTION_CALL
    | LEFT_ROUND_BRACKET LOGICAL_EXPRESSION RIGHT_ROUND_BRACKET
    ;

%%

void yyerror(char *s) { fprintf(stderr, "%s\n", s); }

int main(int argc , char** argv) {
    if(argc > 1) {
        yyin = fopen(argv[1] , "r");
        if(!yyin) {
            fprintf(stderr, "Could not open file: %s\n", argv[1]);
            exit(1);
        }
    }
    else {
        fprintf(stderr, "Test file argument is missing!\n");
        exit(1);
    }
    if(yyparse() == 0)  return 0;
    return 1;
}